<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - geometry - cube</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>

<script src="three.js"></script>

<script id="vertMaterial" type="x-shader/x-vertex">
    #define SHADER_NAME vertMaterial

    precision highp float;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    attribute vec3 position;

    varying vec3 vPosition;

    void main() {
        vec3 positionEye = (modelViewMatrix * vec4(position, 1.0)).xyz;

        vPosition = positionEye;

        gl_Position = projectionMatrix * vec4(positionEye, 1.0);
    }
</script>

<script id="fragMaterial" type="x-shader/x-fragment">
    #define SHADER_NAME fragMaterial;

    #extension GL_OES_standard_derivatives : enable

    precision highp float;

    uniform vec3 color;
    varying vec3 vPosition;

    void main() {
        vec3 fdx = dFdx(vPosition);
        vec3 fdy = dFdy(vPosition);
        vec3 normal = normalize(cross(fdx, fdy));
        float diffuse = dot(normal, vec3(0.0, 0.0, 1.0));

        gl_FragColor = vec4(diffuse * color, 1.0);
    }
</script>

<script>
    let camera, scene, renderer;
    const mesh_list = [];
    let loader = new THREE.BufferGeometryLoader();

    init();
    animate();

    function init() {

        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.z = 40;

        scene = new THREE.Scene();

        loader.load('models/json/suzanne_buffergeometry.json', function(geo) {
            geo = geo.toNonIndexed();
            geo.computeBoundingBox();

            let geometry = geo;
            // let material = new THREE.MeshBasicMaterial();

            let vert = document.getElementById('vertMaterial').textContent;
            let frag = document.getElementById('fragMaterial').textContent;

            const material = new THREE.RawShaderMaterial({
                vertexShader: vert,
                fragmentShader: frag,
                uniforms: {
                    color: {
                        value: new THREE.Color()
                    }
                }
            });

            for (let it = 0; it < 1000; ++it) {
                let mesh = new THREE.Mesh( geometry, material );
                mesh.position.x = Math.random() * 40 - 20;
                mesh.position.y = Math.random() * 40 - 20;
                mesh.position.z = Math.random() * 40 - 20;

                mesh.rotation.x = Math.random() * 2 * Math.PI;
                mesh.rotation.y = Math.random() * 2 * Math.PI;
                mesh.rotation.z = Math.random() * 2 * Math.PI;

                const scale = Math.random()

                mesh.scale.x = scale;
                mesh.scale.y = scale;
                mesh.scale.z = scale;

                mesh.material = material.clone();
                mesh.material.uniforms['color'].value.setHex(Math.random() * 0xffffff);

                mesh_list.push(mesh);

                scene.add( mesh );
            }
        });

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setClearColor(0xddddddd);

        document.body.appendChild( renderer.domElement );

        window.addEventListener( 'resize', onWindowResize, false );

    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function animate() {
        requestAnimationFrame( animate );

        renderer.render( scene, camera );
    }

</script>

</body>
</html>